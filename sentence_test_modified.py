# -*- coding: utf-8 -*-
"""sentence_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VlEEi2zzyioqbWQkwtlgP9w_anngp_11
"""


import tensorflow as tf
import PIL.Image as img
import numpy as np
# data input (img shape: 28*28)
n_input = 28

# total classes (alphabet)
n_classes = 27

# both placeholders are of type float
x = tf.placeholder("float", [None, 28, 28, 1])
y = tf.placeholder("float", [None, n_classes])

def conv2d(x, W, b, strides=1):
    x = tf.nn.conv2d(x, W, strides=[1, strides, strides, 1], padding='SAME')
    x = tf.nn.bias_add(x, b)
    return x

def maxpool2d(x, k=2):
    return tf.nn.max_pool(x, ksize=[1, k, k, 1], strides=[1, k, k, 1],padding='SAME')

weights = {
    'wc1': tf.get_variable('11', shape=(3,3,1,32), initializer=tf.contrib.layers.xavier_initializer()), 
    'wc2': tf.get_variable('21', shape=(3,3,32,32), initializer=tf.contrib.layers.xavier_initializer()),
    'wd1': tf.get_variable('31', shape=(14*14*32,128), initializer=tf.contrib.layers.xavier_initializer()),
    'wd2': tf.get_variable('41', shape=(7*7*32,128), initializer=tf.contrib.layers.xavier_initializer()), 
    'out': tf.get_variable('51', shape=(128,n_classes), initializer=tf.contrib.layers.xavier_initializer())
}
biases = {
    'bc1': tf.get_variable('b11', shape=(32), initializer=tf.contrib.layers.xavier_initializer()),
    'bc2': tf.get_variable('b21', shape=(32), initializer=tf.contrib.layers.xavier_initializer()),
    'bd2': tf.get_variable('b31', shape=(128), initializer=tf.contrib.layers.xavier_initializer()),
    'out': tf.get_variable('b41', shape=(n_classes), initializer=tf.contrib.layers.xavier_initializer())
}

def conv_net(x, weights, biases):  

    conv1 = conv2d(x, weights['wc1'], biases['bc1'])
    conv1 = tf.nn.relu(conv1)
    # choose the max value from a 2*2 matrix window and outputs a 14*14 matrix.
    conv1 = maxpool2d(conv1, k=2)

    conv2 = conv2d(conv1, weights['wc2'], biases['bc2'])
    conv2 = tf.nn.relu(conv2)
    conv2 = maxpool2d(conv2, k=2)
    
    

    # Fully connected layer
    # Reshape conv2 output to fit fully connected layer input
    fc1 = tf.reshape(conv2, [-1, weights['wd2'].get_shape().as_list()[0]])
    fc1 = tf.add(tf.matmul(fc1, weights['wd2']), biases['bd2'])
    fc1 = tf.nn.relu(fc1)
    
    # Output, class prediction
    # Multiply the fully connected layer with the weights and add a bias term. 
    out = tf.add(tf.matmul(fc1, weights['out']), biases['out'])
    return out

pred = conv_net(x, weights, biases)

# Check whether the index of the maximum value of the predicted image is equal to the actual labelled image
correct_prediction = tf.equal(tf.argmax(pred, 1), tf.argmax(y, 1))

# calculate accuracy across all the given images
#accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

prediction = tf.argmax(pred, 1)
actual = tf.argmax(y, 1)
#sorted result(가장 확률이 높은 character부터 순서대로 나열)
top27 = tf.nn.top_k(pred, k=27, sorted=False, name=None)

#data_source의 handwriting sentence를 받아 character 단위로 자르고 픽셀화하는 함수
def Pixelize(data_source):
  
  size = (28,28)
  t = np.ones((28,28),dtype='i')*255
  im = img.open(data_source).convert("L")
  images = []
  for i in range(20):
    area = ((i%5)*120+2,(i//5)*120+2,(i%5+1)*120-2,(i//5+1)*120-2)
    image = im.crop(area)
    image.thumbnail(size)
  
    pix = np.array(image)
    pix = t - pix
  
    images.append(pix)

  images = np.array(images)
  images = images.reshape(-1,28, 28, 1)

  return images

#Pixelize를 통해 숫자데이터롤 바뀐 각각의 character들을 인식하는 함수
def Recognize_cha(model_source, images):
  ListOfLabel = [' ','a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

  saver = tf.train.Saver()

  with tf.Session() as sess:  
      saver.restore(sess, model_source)
      p = sess.run(prediction, feed_dict={x:images})
      topk = sess.run(top27, feed_dict={x:images})
      sess.close()

  sentence = ''
  for i in p:
    sentence = sentence + ListOfLabel[i]

  words = sentence.split(' ')
  return words, topk

#각각의 character들의 확률을 이용해 각 단어를 word_list의 가장 확률이 높은 단어로 바꿔주는 함수
def Recognize_word(words):
  DictOfLabel = {' ':0,'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7, 'h':8, 'i':9, 'j':10, 'k':11, 'l':12, 'm':13, 
               'n':14, 'o':15, 'p':16, 'q':17, 'r':18, 's':19, 't':20, 'u':21, 'v':22, 'w':23, 'x':24, 'y':25, 'z':26}
  word_list = [['on', 'up'],['off', 'red', 'the', 'fan'],['turn', 'down', 'blue', 'door', 'open'],['green',  'light', 'radio', 'close'],['heater','camera','yellow']]
  length = 0
  for i in range(len(words)):
    max = 0
    max_index = 0
    if len(words[i]) == 0:
      length += len(words[i])+1
    else:
      prob = []
      for j in range(len(word_list[len(words[i])-2])):
        score = 0
        word = word_list[len(words[i])-2][j]
        for k in range(len(word)):
          for l in range(27):
            if topk.indices[length+k][l]==DictOfLabel[word[k]]:
              score += topk.values[length+k][l]            
        prob.append(score)
      print(prob)
      for index in range(len(prob)):
        if prob[index]>max:
          max_index = index
          max = prob[index]
      words[i] = word_list[len(words[i])-2][max_index]
      length += len(words[i])+1
      
  return words

# 단어리스트를 명령어로 변환
def Orderize(words):
  object = ['red', 'green', 'yellow', 'fan', 'radio', 'door', 'heater','camera', 'blue']
  pos_order = ['on', 'up', 'open']
  neg_order = ['off', 'down', 'close']
  for i in range(len(pos_order)):
      if  pos_order[i] in words:
          for j, obj in enumerate(object):
              if obj in words:
                  return str(j+1)+'1'
  for i in range(len(neg_order)):
      if  neg_order[i] in words:
          for j, obj in enumerate(object):
              if obj in words:
                  return str(j+1)+'0'


import serial 

arduinoData = serial.Serial('com5',9600) # set comport & baudrate

#---------------------------command---------------------------------------%
images = Pixelize('./handwriting/turn on the radio.jpg')
words, topk = Recognize_cha('./model/model2.ckpt', images)
print(words)
words = Recognize_word(words)
order = Orderize(words)
print(words)
print(order)
arduinoData.write(order.encode()) 
